/*
 * Copyright (c) 2015, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Intel Corporation nor the names of its contributors
 *     may be used to endorse or promote products derived from this software
 *     without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
/*
 * This file contains the definition of the configuration database interface. 
 *
 * It is auto-generated by the db_schema_gen. To make changes to this file 
 * modify the schema.h.template.
 */
 
#ifndef _SCHEMA_H_
#define	_SCHEMA_H_
#ifdef __cplusplus
extern "C" {
#endif

/*!
 * @defgroup db_schema The Database Model
 */

/*!
 * all db functions should return one of these return codes.
 * @ingroup db_schema
 */
enum db_return_codes
{
	DB_SUCCESS = 0, //!< Just in case it's not clear ... this is good
	DB_ERR_FAILURE = -1 //!< Well ... pretty sure this is bad
};

/*!
 * Opaque structure to hide storage details (sqlite)
 * @ingroup db_schema
 */
typedef struct persistentStore PersistentStore;

/*!
 * Creates the memory for and creates a new file for, and instantiates a new PersistentStore.
 * @param path 
 *		Path where the PersistentStore will be stored
 * @param force 
 *		If the file already exists and force is true, then the file will be deleted first
 * @return A pointer to the PersistentStore created.  @ref free_PersistentStore should be called on this pointer
 * to close the file and free memory
 * @ingroup db_schema
 */
PersistentStore *create_PersistentStore(const char *path, int force);

/*!
 * Creates the memory for and instantiates a new PersistentStore object.  It assumes the store already exists.
 * @param path 
 *		Path to the existing PersistentStore file
 * @return A pointer to the PersistentStore created.  @ref free_PersistentStore should be called on this pointer
 * to close the file and free memory
 * @ingroup db_schema
 */
PersistentStore *open_PersistentStore(const char *path);

/*!
 * Close and free the PersistentStore
 * @param Pointer to the PersistentStore created by create_PersistentStore or open_PersistentStore
 * @ingroup db_schema
 */
int free_PersistentStore(PersistentStore **);

/*!
 * Add a new history instance
 * @param[in] p_ps Pointer to the PersistentStore to act upon
 * @param[in] history_name User friendly name to associate to this history instance
 * @param[out] p_history_id User friendly name to associate to this history instance
 * @return enum db_return_codes
 * @ingroup db_schema
 */
enum db_return_codes db_add_history(PersistentStore *p_ps, const char *history_name, int *p_history_id);

/*!
 * Start a new Transaction.
 * @param p_ps Pointer to the PersistentStore to act upon
 * @return enum db_return_codes
 * @details
 * See http://www.sqlite.org/lang_transaction.html for details on using transactions, but basically no change
 * can be made to the database except within a transaction. Any command that changes the database will automatically
 * start a transaction if one is not already in effect. Automatically started transactions are committed when the query finishes.
 * By Beginning a transaction independent of a changing SQL statement then several statements can be committed at once, potentially
 * improving performance.
 * @ingroup db_schema
 */
enum db_return_codes db_begin_transaction(PersistentStore *p_ps);

/*!
 * End a Transaction began with db_begin_transaction
 * @ingroup db_schema
 */
enum db_return_codes db_end_transaction(PersistentStore *p_ps);

/*!
 * undo any changes made within a transaction
 * @ingroup db_schema
 */
enum db_return_codes db_rollback_transaction(PersistentStore *p_ps);

/*!
 * Run a custom SQL Query
 */
 enum db_return_codes db_run_custom_sql(PersistentStore *p_ps, const char *sql);
 
 /*!
 * Returns the number of rows in the table name provided.  If there is an issue with the
 * query (or the table doesn't exist) will return 0.
 */
 enum db_return_codes table_row_count(const PersistentStore *p_ps, const char *table_name, int *p_count);
 
 /*!
 * Execute some SQL on a sqlite db and expect a single int value as result
 */
enum db_return_codes run_scalar_sql(const PersistentStore *p_ps, const char *sql, int *p_scalar);

/*!
 * Execute some SQL on a sqlite db and expect a single char* value as result
 */
enum db_return_codes run_text_scalar_sql(const PersistentStore *p_ps, const char *sql, char *p_value, int len);
 
/*
 * An array containing all history table names automatically generated
 * from the Entity declarations in schema_generator/main.cpp
 */
 extern char* history_table_names[];
	
{{#TABLE}}
/*!
 * @defgroup {{TABLE_NAME}} {{TABLE_NAME}} 
 * @ingroup db_schema
 */
 
 // Lengths for strings and arrays
{{#COLLAPSED_ATTRIBUTE}}
{{#TXT_LEN}}#define	{{TABLE_NAME:x-caps}}_{{ATTRIBUTE_NAME:x-caps}}_LEN {{ATTRIBUTE_STR_LEN}} //!< Max length for {{ATTRIBUTE_NAME}}
{{/TXT_LEN}}
{{#ARY_LEN}}#define	{{TABLE_NAME:x-caps}}_{{ATTRIBUTE_NAME:x-caps}}_COUNT {{ATTRIBUTE_ARRAY_LEN}} //!< Max length for {{ATTRIBUTE_NAME}}
{{/ARY_LEN}}	
{{/COLLAPSED_ATTRIBUTE}}

{{#RELATIONSHIP}}#define	{{TABLE_NAME:x-caps}}_{{ATTRIBUTE_NAME:x-caps}}_COUNT {{ATTRIBUTE_ARRAY_LEN}}  //!< Max number of {{ATTRIBUTE_NAME}}
{{/RELATIONSHIP}}



/*!
 * struct representing the {{TABLE_NAME}} table
 * @ingroup {{TABLE_NAME}}
 */
{{STRUCT_NAME}}
{
{{#COLLAPSED_ATTRIBUTE}}
	{{ATTRIBUTE_C_TYPE:x-replace}} {{ATTRIBUTE_NAME}}{{#ARY_LEN}}[{{TABLE_NAME:x-caps}}_{{ATTRIBUTE_NAME:x-caps}}_COUNT]{{/ARY_LEN}}{{#TXT_LEN}}[{{TABLE_NAME:x-caps}}_{{ATTRIBUTE_NAME:x-caps}}_LEN]{{/TXT_LEN}};
{{/COLLAPSED_ATTRIBUTE}}
{{#RELATIONSHIP}}
	int {{ATTRIBUTE_NAME}}_count;
	struct db_{{ATTRIBUTE_RELATED_ENTITY}} {{ATTRIBUTE_NAME}}[{{TABLE_NAME:x-caps}}_{{ATTRIBUTE_NAME:x-caps}}_COUNT];
{{/RELATIONSHIP}}
};

/*!
 * Helper function to print a db_{{TABLE_NAME}} to the screen.
 * @ingroup {{TABLE_NAME}}
 * @param {{STRUCT_POINTER}}
 * 		value to print
 * @return
 *		void
 */
void db_print_{{TABLE_NAME}}({{STRUCT_NAME}} *p_value);

/*!
 * Create a new row in the {{TABLE_NAME}} table
 * @ingroup {{TABLE_NAME}}
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @param[in] p_{{TABLE_NAME}}
 *		Pointer to the object to be saved to the {{TABLE_NAME}} table
 * @return return_code whether or not it was successful
 */
enum db_return_codes {{F_ADD}}(const PersistentStore *p_ps, struct db_{{TABLE_NAME}} *p_{{TABLE_NAME}});

/*!
 * Get the total number of {{TABLE_NAME}}s
 * @param[in] p_ps
 *		Pointer to the instance of the PersistentStore
 * @param[out] p_count
 * 		Set to the number of {{TABLE_NAME}}s
 * @return whether successful or not
 */
enum db_return_codes {{F_GET_COUNT}}(const PersistentStore *p_ps, int *p_count);

/*!
 * Return all {{TABLE_NAME}}s
 * @ingroup {{TABLE_NAME}}
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @param[out] p_{{TABLE_NAME}}
 *		Pointer to an array of {{TABLE_NAME}} objects that will contain all the {{TABLE_NAME}}s
 * @param[in] {{TABLE_NAME}}_count
 *		Size of p_{{TABLE_NAME}}
 * @return The number of row (to max of {{TABLE_NAME}}_count) on success.  DB_FAILURE on failure.
 */
int {{F_GET_ALL}}(const PersistentStore *p_ps,
	struct db_{{TABLE_NAME}}
	*p_{{TABLE_NAME}},
	int {{TABLE_NAME}}_count);
	
/*!
 * Truncate all the data in the {{TABLE_NAME}} table
 * @ingroup {{TABLE_NAMW}}
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @return return_code whether or not it was successful
 */	
enum db_return_codes {{F_DELETE_TABLE}}(const PersistentStore *p_ps);


{{HISTORY_START}}
/*!
 * delete all entries from {{TABLE_NAME}} history
 * @ingroup {{TABLE_NAME}}
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @return return_code whether or not it was successful
 */
 enum db_return_codes {{F_DELETE_HISTORY}}(const PersistentStore *p_ps);
 {{HISTORY_END}}

{{#TABLE_PK}}
/*!
 * save {{TABLE_NAME}} state
 * @ingroup {{TABLE_NAME}}
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @param[in] history_id
 *		ID of the history to add the {{TABLE_NAME}} to
 * @param[in] p_{{TABLE_NAME}}
 *		{{TABLE_NAME}} to save to history
 * @return return_code whether or not it was successful
 */
enum db_return_codes {{F_SAVE_STATE}}(const PersistentStore *p_ps,
	int history_id,
	struct db_{{TABLE_NAME}} *p_{{TABLE_NAME}});

/*!
 * Return a specific {{TABLE_NAME}} for a given {{PK_ATTRIBUTE_NAME}}
 * @ingroup {{TABLE_NAME}}
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @param[in] {{PK_ATTRIBUTE_NAME}}
 *		{{PK_ATTRIBUTE_NAME}} to identify the correct {{TABLE_NAME}}
 * @param[out] p_{{TABLE_NAME}}
 *		struct to put the {{TABLE_NAME}} retrieved
 * @return return_code whether or not it was successful
 */
enum db_return_codes {{F_GET_BY_PK}}(const PersistentStore *p_ps,
	const {{PK_ATTRIBUTE_C_TYPE}} {{PK_ATTRIBUTE_NAME}},
	struct db_{{TABLE_NAME}} *p_{{TABLE_NAME}});

/*!
 * Update a specific {{TABLE_NAME}} given the original {{PK_ATTRIBUTE_NAME}}
 * @ingroup {{TABLE_NAME}}
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @param[in] {{PK_ATTRIBUTE_NAME}}
 * 		{{PK_ATTRIBUTE_NAME}} points to the {{TABLE_NAME}} to update
 * @param[in] *p_updated_{{TABLE_NAME}}
 *		structure with new values for the {{TABLE_NAME}}
 * @return return_code whether or not it was successful
 */
enum db_return_codes {{F_UPDATE_BY_PK}}(const PersistentStore *p_ps,
	const {{PK_ATTRIBUTE_C_TYPE}} {{PK_ATTRIBUTE_NAME}},
	struct db_{{TABLE_NAME}} *p_updated_{{TABLE_NAME}});

/*!
 * Delete a specific {{TABLE_NAME}} given the {{PK_ATTRIBUTE_NAME}}
 * @ingroup {{TABLE_NAME}}
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @param[in] {{PK_ATTRIBUTE_NAME}}
 *		{{PK_ATTRIBUTE_NAME}} points to the record to delete
 * @return return_code whether or not it was successful
 */
enum db_return_codes {{F_DELETE_BY_PK}}(const PersistentStore *p_ps,
	const {{PK_ATTRIBUTE_C_TYPE}} {{PK_ATTRIBUTE_NAME}});
	
{{/TABLE_PK}}

/*!
 * Return number of matching history rows
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @param[in] history_id
 *		history_id of rows to count
 * @param[out] count
 *		count of rows matching this history_id
 * @return The number of row (to max of {{TABLE_NAME}}_count) on success.  DB_FAILURE on failure.
 */
 enum db_return_codes {{F_GET_HISTORY_BY_HISTORY_ID_COUNT}}(const PersistentStore *p_ps, 
	int history_id,
	int *p_count);
	
/*!
 * Return number of history rows
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @param[out] count
 *		count of rows matching this history_id
 * @return The number of row (to max of {{TABLE_NAME}}_count) on success.  DB_FAILURE on failure.
 */
 enum db_return_codes {{F_GET_HISTORY_COUNT}}(const PersistentStore *p_ps, int *p_count);
	
/*!
 * Return all rows of matching custom sql
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @param[out] {{STRUCT_NAME}}
 *		Structure type for row results
 * @param[in] {{STRUCT_POINTER}}
 *		Pointer to memory to hold row results
 * @param[in] history_id
 *		history_id of rows to return
 * @return The number of row (to max of {{TABLE_NAME}}_count) on success.  DB_FAILURE on failure.
 */
 int {{F_GET_ALL_BY_HISTORY_ID}}(const PersistentStore *p_ps,
	{{STRUCT_NAME}} *{{STRUCT_POINTER}},
	int history_id,
	int {{TABLE_NAME}}_count);

{{!Attribute Specific Functions}}
{{#ATTRIBUTE}}
{{#FK}}
/*!
 * Return the number of {{TABLE_NAME}}s for a given {{ATTRIBUTE_FK_TARGET}}.{{ATTRIBUTE_FK_TARGET_ATTRIBUTE}}
 * @ingroup {{TABLE_NAME}}
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @param[in]  {{ATTRIBUTE_NAME}}
 *		Search {{TABLE_NAME}} and get count for all with passed in {{ATTRIBUTE_NAME}}
 * @param[out]   p_count
 *		Resulting count
 * @return return_code whether or not it was successful
 */
enum db_return_codes {{F_GET_COUNT_BY_FK}} (const PersistentStore *p_ps,
	const {{ATTRIBUTE_C_TYPE}} {{ATTRIBUTE_NAME}}, int *p_count);
	
/*!
 * Return a list of {{TABLE_NAME}}s for a given {{ATTRIBUTE_FK_TARGET}}.{{ATTRIBUTE_FK_TARGET_ATTRIBUTE}}
 * @ingroup {{TABLE_NAME}}
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @param[in]  {{ATTRIBUTE_NAME}}
 *		Search {{TABLE_NAME}} and get all with passed in {{ATTRIBUTE_NAME}}
 * @param[out] p_{{TABLE_NAME}}
 *		memory to hold the found {{TABLE_NAME}}s
 * @param[in]   {{TABLE_NAME}}_count
 *		Size of {{TABLE_NAME}} array passed in
 * @return return_code whether or not it was successful
 */
enum db_return_codes {{F_GET_BY_FK}}(const PersistentStore *p_ps,
	{{ATTRIBUTE_C_TYPE}} {{ATTRIBUTE_NAME}},
	struct db_{{TABLE_NAME}} *p_{{TABLE_NAME}},
	int {{TABLE_NAME}}_count);
	
/*!
 * Delete a list of specific {{TABLE_NAME}}s for a given {{ATTRIBUTE_FK_TARGET}}.{{ATTRIBUTE_FK_TARGET_ATTRIBUTE}}
 * @ingroup {{TABLE_NAME}}
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @param[in]  {{ATTRIBUTE_NAME}}
 *		Search {{TABLE_NAME}} and get all with passed in {{ATTRIBUTE_NAME}}
 * @return return_code whether or not it was successful
 */
enum db_return_codes {{F_DELETE_BY_FK}}(const PersistentStore *p_ps,
	{{ATTRIBUTE_C_TYPE}} {{ATTRIBUTE_NAME}});
{{/FK}}

{{#CLEAR_ATTRIBUTE}}
/*!
 * Clear {{TABLE_NAME}}.{{ATTRIBUTE_NAME}} for all rows
 * @ingroup {{TABLE_NAME}}
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @return return_code whether or not it was successful
 */
 enum db_return_codes {{F_CLEAR_ATTRIBUTE}}(PersistentStore *p_ps);

{{/CLEAR_ATTRIBUTE}}

{{#INDEXPK_ATTRIBUTE}}
/*!
 * Roll {{TABLE_NAME}}s by {{ATTRIBUTE_NAME}} to specified max.
 * @ingroup {{TABLE_NAME}}
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @param[in]  max_rows
 *		The max table size
 * @return return_code whether or not it was successful
 */
enum db_return_codes {{F_ROLL_BY_ATTRIBUTE}}(const PersistentStore *p_ps, int max_rows);

/*!
 * Get the max {{ATTRIBUTE_NAME}} in the {{TABLE_NAME}} table.
 * @ingroup {{TABLE_NAME}}
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @param[in,out]  p_max
 *		The max {{ATTRIBUTE_NAME}}
 * @return return_code whether or not it was successful
 */
enum db_return_codes {{F_GET_MAX_ATTRIBUTE}}(const PersistentStore *p_ps, int *p_max);

{{/INDEXPK_ATTRIBUTE}}
{{/ATTRIBUTE}}
{{/TABLE}}

/*!
 * Delete all history
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @ingroup db_schema
 */
enum db_return_codes db_clear_history(PersistentStore *p_ps);

/*!
 * Delete all state tables
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @ingroup db_schema
 */
enum db_return_codes db_clear_state(PersistentStore *p_ps);

/*!
 * Delete all history
 * @param[in] p_ps
 *		Pointer to the PersistentStore
 * @param[in] max
 * 		Maximum number of histories to keep
 * @ingroup db_schema
 */
enum db_return_codes db_roll_history(PersistentStore *p_ps, int max);

/*!
 * Call sqlite3_update_hook
 * Done here to keep all the persistent store -> db access in this file.
 * @param xCallback
 *		callback to send to sqlite3_update_hook
 */
void update_sqlite3_hook(PersistentStore *p_ps, void (*xCallback)(void*,int,char const *,char const *, long long));
	
#ifdef __cplusplus
}
#endif

#endif /* _SCHEMA_H_ */