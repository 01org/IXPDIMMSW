/*
 * Copyright (c) 2015 2016, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Intel Corporation nor the names of its contributors
 *     may be used to endorse or promote products derived from this software
 *     without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
/*
 * This file contains the implementation of the configuration database interface.
 *
 * It is auto-generated by the db_schema_gen. To make changes to this file 
 * modify the schema.c.template.
 */
 
#include "schema.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <sqlite3.h>


#ifdef __cplusplus
extern "C" {
#endif

// declared in either the test_driver or common/[ostype]_os.c
extern int delete_file(const char *path);

{{>NON_TEMPLATED}}

// Table count is calculated in CrudSchemaGenerator
#define	TABLE_COUNT ({{TABLE_COUNT}})

/*
 * Create a PersistentStore object
 */
PersistentStore *create_PersistentStore(const char *path, int force)
{
	PersistentStore *result = (PersistentStore *)malloc(sizeof (PersistentStore));
	if (result != NULL)
	{
		// check if the file exists - delete it if force
		FILE *file;
		if (force && (file = fopen(path, "r")))
		{
			fclose(file);
			delete_file(path); // make sure doesn't already exist
		}

		// build the schema ...
		struct table { char table_name[256]; char create_statement[2048]; };
		struct table *tables = (struct table *)malloc(TABLE_COUNT * sizeof (struct table));
		if (tables)
		{
			int populate_index = 0;

			tables[populate_index++] = ((struct table){"history",
				"CREATE TABLE history(history_id INTEGER PRIMARY KEY NOT NULL UNIQUE, \
					timestamp DATETIME NOT NULL, history_name TEXT )"});
			{{#TABLE}}tables[populate_index++] = ((struct table){"{{TABLE_NAME}}",
				"CREATE TABLE {{TABLE_NAME}} (       \
					{{#ATTRIBUTE}} {{COLUMN_NAME}} {{ATTRIBUTE_TYPE}} {{#PK}} PRIMARY KEY {{/PK}}{{#AUTOINC_ATTRIBUTE}} AUTOINCREMENT {{/AUTOINC_ATTRIBUTE}}{{#PK}} NOT NULL UNIQUE {{/PK}} {{#ATTRIBUTE_separator}}, \
					{{/ATTRIBUTE_separator}}{{/ATTRIBUTE}} \
					);"}{{HISTORY_START}});
			tables[populate_index++] = ((struct table){"{{TABLE_NAME}}_history",
				"CREATE TABLE {{TABLE_NAME}}_history (       \
					history_id INTEGER NOT NULL, \
					{{#ATTRIBUTE}} {{COLUMN_NAME}} {{ATTRIBUTE_TYPE}} {{#ATTRIBUTE_separator}}, \
					{{/ATTRIBUTE_separator}}{{/ATTRIBUTE}} \
					);"}{{HISTORY_END}});
				{{/TABLE}}

			if (sqlite3_open_v2(path, &(result->db),
				SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|SQLITE_OPEN_FULLMUTEX, NULL) == SQLITE_OK)
			{
				for (int i = 0; i < TABLE_COUNT; i++)
				{
					if (!table_exists(result->db, tables[i].table_name))
					{
						run_sql_no_results(result->db, tables[i].create_statement);
					}
				}
			}
			else
			{
				free_PersistentStore(&result);
			}
			free(tables);
		}
	}
	return result;
}

/*
 * Create an array containing all history table names
 */
char* history_table_names[] = {
{{#TABLE}}{{HISTORY_START}}
	"{{TABLE_NAME}}_history",
{{HISTORY_END}}{{/TABLE}}
	"history",
	"\0"
};

{{#TABLE}}
/*
 * --- {{TABLE_NAME}} ----------------
 */
void {{F_BIND_ENTITY_TO_STMT}}(sqlite3_stmt *p_stmt, {{STRUCT_NAME}} *{{STRUCT_POINTER}})
{
{{#ATTRIBUTE}}
	BIND_{{ATTRIBUTE_TYPE}}(p_stmt, "${{COLUMN_NAME}}", ({{ATTRIBUTE_C_TYPE}}){{STRUCT_POINTER}}->{{FIELD_INDEX_NAME}});
{{/ATTRIBUTE}}
}

void {{F_GET_ENTITY_RELATIONSHIPS}}(const PersistentStore *p_ps,
	sqlite3_stmt *p_stmt, {{STRUCT_NAME}} *{{STRUCT_POINTER}})
{
{{#RELATIONSHIP}}
	// get related data for {{ATTRIBUTE_NAME}}

	{{F_GET_RELATION_COUNT}}(p_ps,
			{{STRUCT_POINTER}}->{{PK_ATTRIBUTE_NAME}},
			&({{STRUCT_POINTER}}->{{ATTRIBUTE_NAME}}_count));
	{{F_GET_RELATION}}(p_ps,
		{{STRUCT_POINTER}}->{{PK_ATTRIBUTE_NAME}},
		{{STRUCT_POINTER}}->{{ATTRIBUTE_NAME}},
		{{STRUCT_POINTER}}->{{ATTRIBUTE_NAME}}_count);
{{/RELATIONSHIP}}
}

{{HISTORY_START}}
void {{F_GET_ENTITY_RELATIONSHIPS_HISTORY}}(const PersistentStore *p_ps,
	sqlite3_stmt *p_stmt, {{STRUCT_NAME}} *{{STRUCT_POINTER}},
	int history_id)
{
{{#RELATIONSHIP}}
	// get related data for {{ATTRIBUTE_NAME}}

	{{F_GET_RELATION_COUNT_HISTORY}}(p_ps,
			{{STRUCT_POINTER}}->{{PK_ATTRIBUTE_NAME}},
			&({{STRUCT_POINTER}}->{{ATTRIBUTE_NAME}}_count), history_id);
	{{F_GET_RELATION_HISTORY}}(p_ps,
		{{STRUCT_POINTER}}->{{PK_ATTRIBUTE_NAME}},
		{{STRUCT_POINTER}}->{{ATTRIBUTE_NAME}},
		{{STRUCT_POINTER}}->{{ATTRIBUTE_NAME}}_count, history_id);
{{/RELATIONSHIP}}
}
{{HISTORY_END}}

void {{F_ROW_TO_ENTITY}}(const PersistentStore *p_ps,
	sqlite3_stmt *p_stmt, {{STRUCT_NAME}} *{{STRUCT_POINTER}})
{
{{#ATTRIBUTE}}
	{{ATTRIBUTE_TYPE}}_COLUMN(p_stmt,
		{{ATTRIBUTE_INDEX}},
		{{STRUCT_POINTER}}->{{FIELD_INDEX_NAME}}{{#TXT_LEN}},
		{{TABLE_NAME:x-caps}}_{{ATTRIBUTE_NAME:x-caps}}_LEN{{/TXT_LEN}});
{{/ATTRIBUTE}}
}

void db_print_{{TABLE_NAME}}({{STRUCT_NAME}} *p_value)
{
	{{#ATTRIBUTE}}
	printf("{{TABLE_NAME}}.{{ATTRIBUTE_NAME}}: {{ATTRIBUTE_C_FORMAT_TYPE}}\n", p_value->{{FIELD_INDEX_NAME}});

    {{/ATTRIBUTE}}
    {{#RELATIONSHIP}}
	for (int i = 0; i < p_value->{{ATTRIBUTE_NAME}}_count; i++)
	{
		db_print_{{ATTRIBUTE_RELATED_ENTITY}}(p_value->{{ATTRIBUTE_NAME}} + i);
	}
    {{/RELATIONSHIP}}
}

enum db_return_codes {{F_ADD}}(const PersistentStore *p_ps,
	{{STRUCT_NAME}} *{{STRUCT_POINTER}})
{
	enum db_return_codes rc = DB_ERR_FAILURE;
	sqlite3_stmt *p_stmt;
	char *sql = 	"INSERT INTO {{TABLE_NAME}} \
		({{#ATTRIBUTE}}{{#NOTAUTOPK_ATTRIBUTE}}{{COLUMN_NAME}}{{/NOTAUTOPK_ATTRIBUTE}}{{#ATTRIBUTE_separator}}{{ATTRIBUTE_SEPERATOR}}{{/ATTRIBUTE_separator}}{{/ATTRIBUTE}})  \
		VALUES 		\
		({{#ATTRIBUTE}}{{#NOTAUTOPK_ATTRIBUTE}}${{COLUMN_NAME}}{{/NOTAUTOPK_ATTRIBUTE}}{{#ATTRIBUTE_separator}}{{ATTRIBUTE_SEPERATOR}}\
		{{/ATTRIBUTE_separator}}{{/ATTRIBUTE}}) ";
	if (SQLITE_PREPARE(p_ps->db, sql, p_stmt))
	{
		{{F_BIND_ENTITY_TO_STMT}}(p_stmt, {{STRUCT_POINTER}});

		if (sqlite3_step(p_stmt) == SQLITE_DONE)
		{
			rc = DB_SUCCESS;
			{{#RELATIONSHIP}}
			//  Add  {{ATTRIBUTE_NAME}}
			for (int i = 0; i < {{STRUCT_POINTER}}->{{ATTRIBUTE_NAME}}_count; i++)
			{
				{{F_ADD_RELATION}}(p_ps, &{{STRUCT_POINTER}}->{{ATTRIBUTE_NAME}}[i]);
			}
			{{/RELATIONSHIP}}

		}
		sqlite3_finalize(p_stmt);
	}
	return rc;
}


enum db_return_codes {{F_GET_COUNT}}(const PersistentStore *p_ps, int *p_count)
{
	return table_row_count(p_ps, "{{TABLE_NAME}}", p_count);
}

int {{F_GET_ALL}}(const PersistentStore *p_ps,
	{{STRUCT_NAME}} *{{STRUCT_POINTER}},
	int {{TABLE_NAME}}_count)
{
	int rc = DB_ERR_FAILURE;
	memset({{STRUCT_POINTER}}, 0, sizeof ({{STRUCT_NAME}}) * {{TABLE_NAME}}_count);
	char *sql = "SELECT \
		{{#ATTRIBUTE}}{{COLUMN_NAME}} \
		{{#ATTRIBUTE_separator}}, {{/ATTRIBUTE_separator}} {{/ATTRIBUTE}} \
		FROM {{TABLE_NAME}} \
		{{#ATTRIBUTE}} {{#ORDERBY_ATTRIBUTE}} ORDER BY {{COLUMN_NAME}}{{/ORDERBY_ATTRIBUTE}}{{/ATTRIBUTE}} \
		{{#ATTRIBUTE}}{{#ORDERBYDESC_ATTRIBUTE}} ORDER BY {{COLUMN_NAME}} DESC {{/ORDERBYDESC_ATTRIBUTE}}{{/ATTRIBUTE}} \
		";
	sqlite3_stmt *p_stmt;
	if (SQLITE_PREPARE(p_ps->db, sql, p_stmt))
	{
		int index = 0;
		while (sqlite3_step(p_stmt) == SQLITE_ROW && index < {{TABLE_NAME}}_count)
		{
			{{F_ROW_TO_ENTITY}}(p_ps, p_stmt, &{{STRUCT_POINTER}}[index]);
			{{F_GET_ENTITY_RELATIONSHIPS}}(p_ps, p_stmt, &{{STRUCT_POINTER}}[index]);
			index++;
		}
		sqlite3_finalize(p_stmt);
		rc = index;
	}
	return rc;
}

enum db_return_codes {{F_DELETE_TABLE}}(const PersistentStore *p_ps)
{
	return run_sql_no_results(p_ps->db, "DELETE FROM {{TABLE_NAME}}");
}

{{#TABLE_PK}}
{{HISTORY_START}}
enum db_return_codes {{F_SAVE_STATE}}(const PersistentStore *p_ps,
	int history_id,
	{{STRUCT_NAME}} *{{STRUCT_POINTER}})
{
	enum db_return_codes rc = DB_SUCCESS;
	{{STRUCT_NAME}} temp;

	/*
	 * Main table - Insert new or update existing
	 */
	if ({{F_GET_BY_PK}}(p_ps, {{STRUCT_POINTER}}->{{PK_ATTRIBUTE_NAME}}, &temp) == DB_SUCCESS)
	{
		rc = {{F_UPDATE_BY_PK}}(p_ps,
				{{STRUCT_POINTER}}->{{PK_ATTRIBUTE_NAME}},
				{{STRUCT_POINTER}});
	}
	else
	{
		sqlite3_stmt *p_stmt;
		char *sql = 	"INSERT INTO {{TABLE_NAME}} \
			({{#ATTRIBUTE}} {{COLUMN_NAME}} {{#ATTRIBUTE_separator}}, {{/ATTRIBUTE_separator}}{{/ATTRIBUTE}})  \
			VALUES 		\
			({{#ATTRIBUTE}}${{COLUMN_NAME}}{{#ATTRIBUTE_separator}}, \
			{{/ATTRIBUTE_separator}}{{/ATTRIBUTE}}) ";
		if (SQLITE_PREPARE(p_ps->db, sql, p_stmt))
		{
			{{F_BIND_ENTITY_TO_STMT}}(p_stmt, {{STRUCT_POINTER}});

			if (sqlite3_step(p_stmt) != SQLITE_DONE)
			{
				rc = DB_ERR_FAILURE;
			}
			sqlite3_finalize(p_stmt);
		}
	}

	/*
	 * Insert as a history
	 */
	if (rc == DB_SUCCESS)
	{
		sqlite3_stmt *p_stmt;
		char *sql = "INSERT INTO {{TABLE_NAME}}_history \
			(history_id, \
				{{#ATTRIBUTE}} {{COLUMN_NAME}}{{#ATTRIBUTE_separator}}, {{/ATTRIBUTE_separator}}{{/ATTRIBUTE}})  \
			VALUES 		($history_id, \
				{{#ATTRIBUTE}} ${{COLUMN_NAME}} {{#ATTRIBUTE_separator}}, \
				{{/ATTRIBUTE_separator}}{{/ATTRIBUTE}})";
		if (SQLITE_PREPARE(p_ps->db, sql, p_stmt))
		{
			BIND_INTEGER(p_stmt, "$history_id", history_id);
			{{F_BIND_ENTITY_TO_STMT}}(p_stmt, {{STRUCT_POINTER}});
			rc = sqlite3_step(p_stmt) == SQLITE_DONE ? DB_SUCCESS : DB_ERR_FAILURE;
			sqlite3_finalize(p_stmt);
		}
		else
		{
			rc = DB_ERR_FAILURE;
		}
	}
	{{#RELATIONSHIP}}
	if (rc == DB_SUCCESS)
	{
    	//  Add  {{ATTRIBUTE_NAME}}_state
    	for (int i = 0; i < {{STRUCT_POINTER}}->{{ATTRIBUTE_NAME}}_count && rc == DB_SUCCESS; i++)
    	{
    		rc = {{F_SAVE_RELATION_STATE}}(p_ps, history_id, &{{STRUCT_POINTER}}->{{ATTRIBUTE_NAME}}[i]);
    	}
	}
	{{/RELATIONSHIP}}

	return rc;
}
{{HISTORY_END}}
enum db_return_codes {{F_GET_BY_PK}}(const PersistentStore *p_ps,
	const {{PK_ATTRIBUTE_C_TYPE}} {{PK_ATTRIBUTE_NAME}},
	{{STRUCT_NAME}} *{{STRUCT_POINTER}})
{
	memset({{STRUCT_POINTER}}, 0, sizeof ({{STRUCT_NAME}}));
	enum db_return_codes rc = DB_ERR_FAILURE;
	sqlite3_stmt *p_stmt;
	char *sql = "SELECT \
		{{#ATTRIBUTE}}{{COLUMN_NAME}}{{#ATTRIBUTE_separator}}, {{/ATTRIBUTE_separator}} {{/ATTRIBUTE}} \
		FROM {{TABLE_NAME}} \
		WHERE  {{PK_ATTRIBUTE_NAME}} = ${{PK_ATTRIBUTE_NAME}}";
	if (SQLITE_PREPARE(p_ps->db, sql, p_stmt))
	{
		BIND_{{PK_ATTRIBUTE_TYPE}}(p_stmt, "${{PK_ATTRIBUTE_NAME}}", ({{PK_ATTRIBUTE_C_TYPE}}){{PK_ATTRIBUTE_NAME}});

		if (sqlite3_step(p_stmt) == SQLITE_ROW)
		{
			{{F_ROW_TO_ENTITY}}(p_ps, p_stmt, {{STRUCT_POINTER}});
			{{F_GET_ENTITY_RELATIONSHIPS}}(p_ps, p_stmt, {{STRUCT_POINTER}});
			rc = DB_SUCCESS;
		}
		sqlite3_finalize(p_stmt);
	}
	return rc;
}

enum db_return_codes {{F_UPDATE_BY_PK}}(const PersistentStore *p_ps,
	const {{PK_ATTRIBUTE_C_TYPE}} {{PK_ATTRIBUTE_NAME}},
	{{STRUCT_NAME}} *{{STRUCT_POINTER}})
{
	sqlite3_stmt *p_stmt;
	enum db_return_codes rc = DB_SUCCESS;
	int sqlrc = 0;
	char *sql = "UPDATE {{TABLE_NAME}} \
	SET \
	{{#ATTRIBUTE}}{{COLUMN_NAME}}=${{COLUMN_NAME}} \
		{{#ATTRIBUTE_separator}}, {{/ATTRIBUTE_separator}} {{/ATTRIBUTE}} \
	WHERE {{PK_ATTRIBUTE_NAME}}=${{PK_ATTRIBUTE_NAME}} ";
	if (SQLITE_PREPARE(p_ps->db, sql, p_stmt))
	{
		BIND_{{PK_ATTRIBUTE_TYPE}}(p_stmt, "${{PK_ATTRIBUTE_NAME}}", ({{PK_ATTRIBUTE_C_TYPE}}){{PK_ATTRIBUTE_NAME}});
		{{F_BIND_ENTITY_TO_STMT}}(p_stmt, {{STRUCT_POINTER}});
		sqlrc = sqlite3_step(p_stmt) == SQLITE_OK;
		sqlite3_finalize(p_stmt);

		if (sqlrc != SQLITE_OK)
		{
			rc = DB_ERR_FAILURE;
		}
	}
	else
	{
		rc = DB_ERR_FAILURE;
	}
	return rc;
}

enum db_return_codes {{F_DELETE_BY_PK}}(const PersistentStore *p_ps,
	const {{PK_ATTRIBUTE_C_TYPE}} {{PK_ATTRIBUTE_NAME}})
{
	enum db_return_codes rc = DB_ERR_FAILURE;
	sqlite3_stmt *p_stmt;
	char *sql = "DELETE FROM {{TABLE_NAME}} \
				 WHERE {{PK_ATTRIBUTE_NAME}} = ${{PK_ATTRIBUTE_NAME}}";

	if (SQLITE_PREPARE(p_ps->db, sql, p_stmt))
	{
		BIND_{{PK_ATTRIBUTE_TYPE}}(p_stmt, "${{PK_ATTRIBUTE_NAME}}", ({{PK_ATTRIBUTE_C_TYPE}}){{PK_ATTRIBUTE_NAME}});
		if (sqlite3_step(p_stmt) == SQLITE_DONE)
		{
			rc = DB_SUCCESS;
		}
		sqlite3_finalize(p_stmt);
	}


	return rc;
}
{{/TABLE_PK}}

{{HISTORY_START}}
enum db_return_codes {{F_GET_HISTORY_BY_HISTORY_ID_COUNT}}(const PersistentStore *p_ps, 
	int history_id,
	int *p_count)
{
	enum db_return_codes rc = DB_ERR_FAILURE;
	*p_count = 0;
	sqlite3_stmt *p_stmt;
	char buffer[1024];
	snprintf(buffer, 1024, "select count(*) FROM {{TABLE_NAME}}_history WHERE  history_id = '%d'", history_id);
	if (SQLITE_PREPARE(p_ps->db, buffer, p_stmt))
	{
		if (sqlite3_step(p_stmt) == SQLITE_ROW)
		{
			*p_count = sqlite3_column_int(p_stmt, 0);
			rc = DB_SUCCESS;
		}
		// cleanup
		sqlite3_finalize(p_stmt);
	}
	return rc;
}

enum db_return_codes {{F_GET_HISTORY_COUNT}}(const PersistentStore *p_ps, int *p_count)
{
	enum db_return_codes rc = DB_ERR_FAILURE;
	*p_count = 0;
	sqlite3_stmt *p_stmt;
	char buffer[1024];
	snprintf(buffer, 1024, "select count(*) FROM {{TABLE_NAME}}_history");
	if (SQLITE_PREPARE(p_ps->db, buffer, p_stmt))
	{
		if (sqlite3_step(p_stmt) == SQLITE_ROW)
		{
			*p_count = sqlite3_column_int(p_stmt, 0);
			rc = DB_SUCCESS;
		}
		// cleanup
		sqlite3_finalize(p_stmt);
	}
	return rc;
}

int {{F_GET_ALL_BY_HISTORY_ID}}(const PersistentStore *p_ps,
	{{STRUCT_NAME}} *{{STRUCT_POINTER}},
	int history_id,
	int {{TABLE_NAME}}_count)
{
	int rc = DB_ERR_FAILURE;
	memset({{STRUCT_POINTER}}, 0, sizeof ({{STRUCT_NAME}}) * {{TABLE_NAME}}_count);
	sqlite3_stmt *p_stmt;

	char buffer[1024];
	snprintf(buffer, 1024, "SELECT \
		{{#ATTRIBUTE}}{{COLUMN_NAME}}{{#ATTRIBUTE_separator}}, {{/ATTRIBUTE_separator}} {{/ATTRIBUTE}} \
		FROM {{TABLE_NAME}}_history \
		WHERE  history_id = '%d'", history_id);
	if (SQLITE_PREPARE(p_ps->db, buffer, p_stmt))
	{
		int index = 0;
		BIND_INTEGER(p_stmt, "$history_id", history_id);
		while (sqlite3_step(p_stmt) == SQLITE_ROW && index < {{TABLE_NAME}}_count)
		{
		rc = DB_SUCCESS;
		{{F_ROW_TO_ENTITY}}(p_ps, p_stmt, &{{STRUCT_POINTER}}[index]);
		{{F_GET_ENTITY_RELATIONSHIPS_HISTORY}}(p_ps, p_stmt, &{{STRUCT_POINTER}}[index], history_id);
			index++;
		}
		sqlite3_finalize(p_stmt);
		rc = index;
	}
	return rc;
}

enum db_return_codes {{F_DELETE_HISTORY}}(const PersistentStore *p_ps)
{
	return run_sql_no_results(p_ps->db, "DELETE FROM {{TABLE_NAME}}_history");
}
{{HISTORY_END}}

{{!Attribute Specific Functions}}
{{#ATTRIBUTE}}
{{#FK}}

enum db_return_codes {{F_GET_COUNT_BY_FK}}(
	const PersistentStore *p_ps,
	const {{ATTRIBUTE_C_TYPE}} {{ATTRIBUTE_NAME}},
	int *p_count)
{
	enum db_return_codes rc = DB_ERR_FAILURE;
	*p_count = 0;
	const char *sql = "SELECT COUNT (*) FROM {{TABLE_NAME}} WHERE {{ATTRIBUTE_NAME}} = ${{ATTRIBUTE_NAME}}";
	sqlite3_stmt *p_stmt;
	if (SQLITE_PREPARE(p_ps->db, sql, p_stmt))
	{
		BIND_{{ATTRIBUTE_TYPE}}(p_stmt, "${{COLUMN_NAME}}", ({{ATTRIBUTE_C_TYPE}}){{COLUMN_NAME}});
		if (sqlite3_step(p_stmt) == SQLITE_ROW)
		{
			*p_count = sqlite3_column_int(p_stmt, 0);
			rc = DB_SUCCESS;
		}
		sqlite3_finalize(p_stmt);
	}

	return rc;
}

enum db_return_codes {{F_GET_COUNT_BY_FK_HISTORY}}(
	const PersistentStore *p_ps,
	const {{ATTRIBUTE_C_TYPE}} {{ATTRIBUTE_NAME}},
	int *p_count, int history_id)
{
	enum db_return_codes rc = DB_ERR_FAILURE;
	*p_count = 0;
	const char *sql = "SELECT COUNT (*) FROM {{TABLE_NAME}}_history "
		"WHERE {{ATTRIBUTE_NAME}} = ${{ATTRIBUTE_NAME}} "
			"AND history_id=$history_id";
	sqlite3_stmt *p_stmt;
	if (SQLITE_PREPARE(p_ps->db, sql, p_stmt))
	{
		BIND_{{ATTRIBUTE_TYPE}}(p_stmt, "${{COLUMN_NAME}}", ({{ATTRIBUTE_C_TYPE}}){{COLUMN_NAME}});
		BIND_INTEGER(p_stmt, "$history_id", history_id);
		if (sqlite3_step(p_stmt) == SQLITE_ROW)
		{
			*p_count = sqlite3_column_int(p_stmt, 0);
			rc = DB_SUCCESS;
		}
		sqlite3_finalize(p_stmt);
	}

	return rc;
}

enum db_return_codes {{F_GET_BY_FK}}(const PersistentStore *p_ps,
	{{ATTRIBUTE_C_TYPE}} {{ATTRIBUTE_NAME}},
	{{STRUCT_NAME}} *{{STRUCT_POINTER}},
	int {{TABLE_NAME}}_count)
{
	enum db_return_codes rc = DB_ERR_FAILURE;
	sqlite3_stmt *p_stmt;
	char *sql = "SELECT \
		{{#ATTRIBUTE}} {{COLUMN_NAME}} {{#ATTRIBUTE_separator}}, {{/ATTRIBUTE_separator}}{{/ATTRIBUTE}} \
		FROM {{TABLE_NAME}} \
		WHERE  {{ATTRIBUTE_NAME}} = ${{ATTRIBUTE_NAME}}";
	if (SQLITE_PREPARE(p_ps->db, sql, p_stmt))
	{
		rc = DB_SUCCESS;
		BIND_{{ATTRIBUTE_TYPE}}(p_stmt, "${{COLUMN_NAME}}", ({{ATTRIBUTE_C_TYPE}}){{COLUMN_NAME}});
		int index = 0;
		while (sqlite3_step(p_stmt) == SQLITE_ROW && index < {{TABLE_NAME}}_count)
		{
			{{F_ROW_TO_ENTITY}}(p_ps, p_stmt, &{{STRUCT_POINTER}}[index]);
			{{F_GET_ENTITY_RELATIONSHIPS}}(p_ps, p_stmt, &{{STRUCT_POINTER}}[index]);
			index++;
		}
		sqlite3_finalize(p_stmt);
	}
	return rc;
}
enum db_return_codes {{F_GET_BY_FK_HISTORY}}(const PersistentStore *p_ps,
	{{ATTRIBUTE_C_TYPE}} {{ATTRIBUTE_NAME}},
	{{STRUCT_NAME}} *{{STRUCT_POINTER}},
	int {{TABLE_NAME}}_count, int history_id)
{
	enum db_return_codes rc = DB_ERR_FAILURE;
	sqlite3_stmt *p_stmt;
	char *sql = "SELECT \
		{{#ATTRIBUTE}} {{COLUMN_NAME}} {{#ATTRIBUTE_separator}}, {{/ATTRIBUTE_separator}}{{/ATTRIBUTE}} \
		FROM {{TABLE_NAME}}_history \
		WHERE  {{ATTRIBUTE_NAME}} = ${{ATTRIBUTE_NAME}} AND history_id=$history_id";
	if (SQLITE_PREPARE(p_ps->db, sql, p_stmt))
	{
		rc = DB_SUCCESS;
		BIND_{{ATTRIBUTE_TYPE}}(p_stmt, "${{COLUMN_NAME}}", ({{ATTRIBUTE_C_TYPE}}){{COLUMN_NAME}});
		BIND_INTEGER(p_stmt, "$history_id", history_id);
		int index = 0;
		while (sqlite3_step(p_stmt) == SQLITE_ROW && index < {{TABLE_NAME}}_count)
		{
			{{F_ROW_TO_ENTITY}}(p_ps, p_stmt, &{{STRUCT_POINTER}}[index]);
			{{F_GET_ENTITY_RELATIONSHIPS}}(p_ps, p_stmt, &{{STRUCT_POINTER}}[index]);
			index++;
		}
		sqlite3_finalize(p_stmt);
	}
	return rc;
}

enum db_return_codes {{F_DELETE_BY_FK}}(const PersistentStore *p_ps,
	{{ATTRIBUTE_C_TYPE}} {{ATTRIBUTE_NAME}})
{
	enum db_return_codes rc = DB_ERR_FAILURE;
	sqlite3_stmt *p_stmt;
	char *sql = "DELETE FROM {{TABLE_NAME}} \
				 WHERE {{ATTRIBUTE_NAME}} = ${{ATTRIBUTE_NAME}}";

	if (SQLITE_PREPARE(p_ps->db, sql, p_stmt))
	{
		BIND_{{ATTRIBUTE_TYPE}}(p_stmt, "${{COLUMN_NAME}}", ({{ATTRIBUTE_C_TYPE}}){{COLUMN_NAME}});
		if (sqlite3_step(p_stmt) == SQLITE_DONE)
		{
			rc = DB_SUCCESS;
		}
		sqlite3_finalize(p_stmt);
	}

	return rc;
}

{{/FK}}
{{#CLEAR_ATTRIBUTE}}
/*!
 * Clear {{TABLE_NAME}}.{{ATTRIBUTE_NAME}}
 */
enum db_return_codes  {{F_CLEAR_ATTRIBUTE}}(PersistentStore *p_ps)
{
	enum db_return_codes rc =
		run_sql_no_results(p_ps->db, "UPDATE {{TABLE_NAME}} SET {{COLUMN_NAME}}=''");
{{HISTORY_START}}
	if (rc == DB_SUCCESS)
	{
		rc = run_sql_no_results(p_ps->db, "UPDATE {{TABLE_NAME}}_history SET {{COLUMN_NAME}}=''");
	}
{{HISTORY_END}}
	return rc;
}
{{/CLEAR_ATTRIBUTE}}

{{#INDEXPK_ATTRIBUTE}}
/*!
 * Roll {{TABLE_NAME}}s by {{ATTRIBUTE_NAME}} to specified max.
 */
enum db_return_codes {{F_ROLL_BY_ATTRIBUTE}}(const PersistentStore *p_ps,
	int max_rows)
{
	enum db_return_codes rc = DB_ERR_FAILURE;
	sqlite3_stmt *p_stmt;
	char sql[1024];
	snprintf(sql, 1024,
				"DELETE FROM {{TABLE_NAME}} "
				"WHERE {{ATTRIBUTE_NAME}} NOT IN ("
				"SELECT {{ATTRIBUTE_NAME}} "
				"FROM {{TABLE_NAME}} "
				"ORDER BY {{ATTRIBUTE_NAME}} DESC "
				"LIMIT %d)", max_rows); 

	if (SQLITE_PREPARE(p_ps->db, sql, p_stmt))
	{
		if (sqlite3_step(p_stmt) == SQLITE_DONE)
		{
			rc = DB_SUCCESS;
		}
		sqlite3_finalize(p_stmt);
	}

	return rc;
}

/*!
 * Get the max {{ATTRIBUTE_NAME}} in the {{TABLE_NAME}} table.
 */
enum db_return_codes {{F_GET_MAX_ATTRIBUTE}}(const PersistentStore *p_ps, int *p_max)
{
	enum db_return_codes rc = DB_ERR_FAILURE;
	if (p_max)
	{
		if ((rc = run_scalar_sql(p_ps, 
			"SELECT MAX({{ATTRIBUTE_NAME}}) FROM {{TABLE_NAME}}", p_max)) 
			==  DB_SUCCESS)
		{
			(*p_max)++;
		}
	}
	return rc;
}

{{/INDEXPK_ATTRIBUTE}}

{{/ATTRIBUTE}}

/*
 * --- END {{TABLE_NAME}} ----------------
 */
{{/TABLE}}

/*
 * Delete all histories
 */
enum db_return_codes db_clear_history(PersistentStore *p_ps)
{
	enum db_return_codes rc = DB_SUCCESS;
	{{#TABLE}}{{HISTORY_START}}
	KEEP_DB_ERROR(rc, run_sql_no_results(p_ps->db, "DELETE FROM {{TABLE_NAME}}_history"));
	{{HISTORY_END}}{{/TABLE}}
	KEEP_DB_ERROR(rc, run_sql_no_results(p_ps->db, "DELETE FROM history"));
	return rc;
}

/*
 * Delete all "simulation" tables and their history tables
 */
enum db_return_codes db_clear_state(PersistentStore *p_ps)
{
	enum db_return_codes rc = DB_SUCCESS;
	{{#TABLE}}{{HISTORY_START}}
	KEEP_DB_ERROR(rc, run_sql_no_results(p_ps->db, "DELETE FROM {{TABLE_NAME}}_history"));
	KEEP_DB_ERROR(rc, run_sql_no_results(p_ps->db, "DELETE FROM {{TABLE_NAME}}"));
	{{HISTORY_END}}{{/TABLE}}
	KEEP_DB_ERROR(rc, run_sql_no_results(p_ps->db, "DELETE FROM history"));
	return rc;
}

/*
 * Roll histories to a max count
 */
enum db_return_codes db_roll_history(PersistentStore *p_ps, int max)
{
	enum db_return_codes rc = DB_SUCCESS;
	
	db_begin_transaction(p_ps);
	char sql[1024];
	{{#TABLE}}{{HISTORY_START}}
	snprintf(sql, 1024,
				"DELETE FROM {{TABLE_NAME}}_history "
				"WHERE history_id NOT IN "
				"(SELECT history_id FROM history ORDER BY ROWID DESC LIMIT %d)", max); 
	KEEP_DB_ERROR(rc, run_sql_no_results(p_ps->db, sql));
	{{HISTORY_END}}{{/TABLE}}
	
	snprintf(sql, 1024,
				"DELETE FROM history "
				"WHERE history_id NOT IN "
				"(SELECT history_id FROM history ORDER BY ROWID DESC LIMIT %d)", max); 
	KEEP_DB_ERROR(rc, run_sql_no_results(p_ps->db, sql));
	db_end_transaction(p_ps);
	
	return rc;
}
 
#ifdef __cplusplus
}
#endif
